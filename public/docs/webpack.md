TODO:

1. move `lodash-es` to vendors?
2. lazy @sentry ?
3. remove jquery from v2 dependencies
4. remove file-loader
5. Delete source maps after uploading to sentry.io, delete-sourcemap-webpack-plugin не совместим с webpack 5


## Issues

### core-js bundle size

Сейчас используются следующие настройки для Babel:

```
  "presets": [
    ["@babel/preset-env", {
      "targets": { ... },  // .browserslistrc
      "useBuiltIns": "entry",
      "corejs": 3
    }]
  ],
  "plugins": [
    ["@babel/transform-runtime", {
      "corejs": false
    }]
  ]
```

`"useBuiltIns": "entry"` означает, что все вхождения `import core-js/stable` (рекомендуется использовать 1 раз в начале кода приложения)
будут заменены на импорт только тех полифиллов, которые нужны для перечисленных `targets`.
Эти полифиллы будут протекать в global namespace (в случае браузера в объект window) и в целом
для приложения это нормально, т.к. мы знаем, в каком окружении приложение будет выполняться.

Настройка corejs в `@babel/transform-runtime` выставлена в `false`, т.е. плагин не пытается импортировать
модули из `@babel/runtime-corejs3/core-js-stable` (которые в свою очередь ссылаются на `core-js-pure` - честный импорт функций без зависимостей от globals),
чтобы у нас не получилось дублирования реализаций из core-js/core-js-pure в результирующем бандле.

Плюс реализации: сильно лучше, чем импорт абсолютно всех полифиллов из библиотеки core-js.

Минус: есть лишние полифиллы, которые не используются нашим приложением или другими зависимостями из node_modules/.
Чем старее поддерживаемые браузеры, тем больше лишних полифиллов.

Почему такие настройки предпочтительнее, чем остальные? Рассмотрим другие варианты.


**Вариант с `useBuiltIns: "usage"`:**

```
  "presets": [
    ["@babel/preset-env", {
      "targets": { ... },  // .browserslistrc
      "useBuiltIns": "usage",
      "corejs": 3
    }]
  ],
  "plugins": [
    ["@babel/transform-runtime", {
      "corejs": false
    }]
  ]
```

Так мы в каждый файл импортируем core-js зависимости, которые используются
нашим кодом. Кажется, что всё хорошо и это ровно то, что нам требуется - дальше
webpack может вынуть все core-js зависимости в отдельный chunk и избежать дублирования кода,
но `@babel/transform-runtime` прокидывает ссылки на `@babel/runtime/helpers/...`, которые могут иметь глобальные зависимости,
требующие полифиллов! Если наш код эти зависимости не использует, то получим ошибку в старых браузерах.
Можно было бы попытаться найти все такие зависимости, но отследить их для всех targets крайне сложно.

Note: Все остальные зависимости (не только `@babel/runtime/helpers`) из node_modules/
могут так же требовать каких-то полифиллов, которые мы не используем напрямую в нашем коде.

Если поменять настройку `corejs: 3` в `@babel/transform-runtime`, то станет только хуже, т.к.
помимо core-js зависимостей, будут ссылки на `@babel/runtime-corejs3/core-js-stable/` и размер бандла сильно увеличится.

**Вариант с `useBuiltIns: false`:**

```
  "presets": [
    ["@babel/preset-env", {
      "targets": { ... },  // .browserslistrc
      "useBuiltIns": false,
    }]
  ],
  "plugins": [
    ["@babel/transform-runtime", {
      "corejs": 3
    }]
  ]
```

`@babel/preset-env` ничего не делает с полифиллами, а `@babel/transform-runtime`
подставляет полифиллы абсолютно для всех builtins, без учёта `targets`, т.е. даже если
все целевые браузеры имеют какой-то API, все связанные с ним полифиллы будут всё равно добавлены.
Т.к. у нас есть webpack, зависимости из core-js-pure мы можем сложить в отдельный chunk,
избежав дублирования, но этот вариант настройки всё равно проигрывает первоначальному варианту, т.к. там учитываются targets.

Note: Хороший вариант для написания библиотеки, когда мы не знаем про окружение, в котором она будет использоваться.

Итог: Проблема известная, её решение явно можно автоматизировать, но делать этого никто не торопится.
Если это и произойдёт, то вот в этом репозитории https://github.com/babel/babel-polyfills.
Пока в статусе experimental и страшно использовать, можно и с лишними полифиллами пожить.
